quit
@oauth = OAuth.new(@api.oauth)
OAuth.new(@api.oauth)
@api.oauth
quit
@request
send(@request)
quit
determine_request
@api
@request
quit
send(@request)
c
body
code_status
quit
data = @oauth.access_token.get(@api.get)
data.code
data.body
p data
data.response
data
data = @oauth.access_token.get(@api.get.to_s)
@oauth.access_token.get(@api.get.to_s)
quit
@oauth.access_token
@oauth.access_token.get(@api.get.to_s)
@api.get
@oauth.access_token.get(@api.get)
quit
@api.get.to_s
http.get
http.start
http.ciphers = ['DES-CBC3-SHA']
http.ssl_version = :TLSv1
http.start
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
http.start
request.oauth! http, @oauth.consumer_key, @oauth.access_token
http.ciphers = ['RC4-SHA']
http.ssl_version = :TLSv1
http.use_ssl     = true
 http             = Net::HTTP.new @api.get.host
request = Net::HTTP::Get.new(@api.get)
http.start
http.ciphers = ['RC4-SHA']
http.ssl_cipher = 'rc4-sha'
http.ssl_version = 'TLSv1' 
http.start
request.oauth! http, @oauth.consumer_key, @oauth.access_token
http.verify_mode
http.verify_mode = OpenSSL::SSL::VERIFY_PEER
http.use_ssl     = true
http             = Net::HTTP.new @api.get.host
response.body
response = http.request request
http.start
request.oauth! http, @oauth.consumer_key, @oauth.access_token
http             = Net::HTTP.new @api.get.host
http             = Net::HTTP.new @api.get.host, @api.get.host.port
request = Net::HTTP::Get.new(@api.get)
quit
@api.get
@api
http             = Net::HTTP.new @api.get.host, @api.get.host.port
request = Net::HTTP::Get.new(@api.get)
c
@response.body
@response
quit
redis.add(http.body) if http.get
c
@uri
c
@threads << Thread.new { main_loop(conn) }
conn
c
@connections.first.api
@connections
c
cli.runner
c
cli.config
cli
c
@parser
c
OptionParser.new
c
@parser
c
@parser
@config
c
@parser
@argv
quit
x.code
x.body
x = client.get
client.get
client
api
c
conn.lrange('services', 0, 4)
quit
conn.lrange('services', 0, 4)
conn.llen('services')
conn.get('services')
conn
